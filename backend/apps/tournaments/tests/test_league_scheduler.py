"""
Tests for League Scheduling Engine.
"""

import pytest
from datetime import datetime, timedelta, time
from django.test import TestCase
from django.utils import timezone
from django.contrib.auth import get_user_model

from apps.clubs.models import Club, Court
from apps.clients.models import ClientProfile
from apps.tournaments.models import (
    League, LeagueTeam, LeagueMatch, LeagueSchedule,
    ScheduleConstraint, ScheduleOptimization
)
from apps.tournaments.league_scheduler import LeagueScheduler
from apps.tournaments.geographic_optimizer import GeographicOptimizer
from apps.tournaments.rescheduler import MatchRescheduler, RescheduleReason

User = get_user_model()


class LeagueSchedulerTestCase(TestCase):
    """Test cases for League Scheduler."""
    
    def setUp(self):
        """Set up test data."""
        # Create test user and club
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass'
        )
        
        self.club = Club.objects.create(
            name='Test Club',
            address='Test Address',
            city='Test City',
            phone='123-456-7890'
        )
        
        # Create test courts
        self.courts = []
        for i in range(3):
            court = Court.objects.create(
                club=self.club,
                name=f'Court {i+1}',
                surface_type='clay',
                is_active=True
            )
            self.courts.append(court)
        
        # Create test league
        self.league = League.objects.create(
            club=self.club,
            name='Test League',
            description='A test league',
            format='round_robin',
            frequency='weekly',
            start_date=timezone.now().date() + timedelta(days=7),
            end_date=timezone.now().date() + timedelta(days=90),
            preferred_start_hour=time(19, 0),
            preferred_end_hour=time(22, 0),
            is_active=True
        )
        
        # Create test players and teams
        self.teams = []
        for i in range(8):  # 8 teams for good round-robin testing
            # Create players
            player1 = User.objects.create_user(
                username=f'player{i*2+1}',
                email=f'player{i*2+1}@example.com',
                first_name=f'Player{i*2+1}',
                last_name='Test'
            )
            player2 = User.objects.create_user(
                username=f'player{i*2+2}',
                email=f'player{i*2+2}@example.com',
                first_name=f'Player{i*2+2}',
                last_name='Test'
            )
            
            # Create client profiles
            profile1 = ClientProfile.objects.create(
                user=player1,
                phone='123-456-789' + str(i*2+1),
                emergency_contact='Emergency' + str(i*2+1)
            )
            profile2 = ClientProfile.objects.create(
                user=player2,
                phone='123-456-789' + str(i*2+2),
                emergency_contact='Emergency' + str(i*2+2)
            )
            
            # Create team
            team = LeagueTeam.objects.create(
                league=self.league,
                name=f'Team {i+1}',
                player1=profile1,
                player2=profile2,
                division=1,
                current_points=0
            )
            self.teams.append(team)
    
    def test_scheduler_initialization(self):
        """Test scheduler initialization."""
        scheduler = LeagueScheduler(self.league)
        
        self.assertEqual(scheduler.league, self.league)
        self.assertEqual(len(scheduler.teams), 8)
        self.assertEqual(scheduler.constraints.count(), 0)
    
    def test_algorithm_selection(self):
        """Test automatic algorithm selection."""
        scheduler = LeagueScheduler(self.league)
        
        # For 8 teams with no constraints, should select genetic or hybrid
        algorithm = scheduler._select_best_algorithm()
        self.assertIn(algorithm, ['genetic', 'hybrid', 'constraint_solver'])
    
    def test_round_robin_pair_generation(self):
        """Test round-robin match pair generation."""
        scheduler = LeagueScheduler(self.league)
        pairs = scheduler._generate_round_robin_pairs()
        
        # For 8 teams, should have 8 * 7 / 2 = 28 matches
        self.assertEqual(len(pairs), 28)
        
        # Check that all teams appear equally
        team_counts = {}
        for home, away in pairs:
            team_counts[home.id] = team_counts.get(home.id, 0) + 1
            team_counts[away.id] = team_counts.get(away.id, 0) + 1
        
        # Each team should play 7 matches (against all other teams)
        for count in team_counts.values():\n            self.assertEqual(count, 7)\n    \n    def test_double_round_robin_generation(self):\n        \"\"\"Test double round-robin format.\"\"\"\n        self.league.format = 'double_round_robin'\n        self.league.save()\n        \n        scheduler = LeagueScheduler(self.league)\n        pairs = scheduler._generate_match_pairs()\n        \n        # For double round-robin with 8 teams: 2 * (8 * 7 / 2) = 56 matches\n        self.assertEqual(len(pairs), 56)\n    \n    def test_multi_division_generation(self):\n        \"\"\"Test multi-division format.\"\"\"\n        self.league.format = 'multi_division'\n        self.league.divisions = 2\n        self.league.save()\n        \n        # Assign teams to different divisions\n        for i, team in enumerate(self.teams):\n            team.division = 1 if i < 4 else 2\n            team.save()\n        \n        scheduler = LeagueScheduler(self.league)\n        pairs = scheduler._generate_match_pairs()\n        \n        # Each division has 4 teams, so 4 * 3 / 2 = 6 matches per division\n        # Total: 6 * 2 = 12 matches\n        self.assertEqual(len(pairs), 12)\n    \n    def test_time_slot_generation(self):\n        \"\"\"Test time slot generation.\"\"\"\n        scheduler = LeagueScheduler(self.league)\n        time_slots = scheduler._get_available_time_slots()\n        \n        # Should have time slots for each day in the league period\n        self.assertGreater(len(time_slots), 0)\n        \n        # Check time slots are within preferred hours\n        for slot in time_slots[:10]:  # Check first 10 slots\n            slot_time = slot['datetime'].time()\n            self.assertGreaterEqual(slot_time, self.league.preferred_start_hour)\n            self.assertLessEqual(slot_time, self.league.preferred_end_hour)\n    \n    def test_slot_quality_calculation(self):\n        \"\"\"Test time slot quality scoring.\"\"\"\n        scheduler = LeagueScheduler(self.league)\n        \n        # Prime time slot (evening)\n        prime_time = datetime.combine(\n            timezone.now().date() + timedelta(days=1),\n            time(20, 0)  # 8 PM\n        )\n        prime_quality = scheduler._calculate_slot_quality(prime_time, self.courts[0])\n        \n        # Off-peak time slot (morning)\n        offpeak_time = datetime.combine(\n            timezone.now().date() + timedelta(days=1),\n            time(10, 0)  # 10 AM\n        )\n        offpeak_quality = scheduler._calculate_slot_quality(offpeak_time, self.courts[0])\n        \n        # Prime time should have higher quality\n        self.assertGreater(prime_quality, offpeak_quality)\n    \n    def test_genetic_algorithm_schedule(self):\n        \"\"\"Test genetic algorithm schedule generation.\"\"\"\n        scheduler = LeagueScheduler(self.league)\n        \n        # Generate match pairs and time slots\n        match_pairs = scheduler._generate_match_pairs()\n        time_slots = scheduler._get_available_time_slots()\n        \n        # Limit time slots for faster testing\n        time_slots = time_slots[:50]\n        \n        # Generate schedule with genetic algorithm\n        schedule = scheduler._optimize_with_genetic_algorithm(match_pairs, time_slots)\n        \n        # Should have assignments for all matches\n        self.assertEqual(len(schedule), len(match_pairs))\n        \n        # All assignments should have valid time slots\n        for assignment in schedule.values():\n            self.assertIn('time_slot', assignment)\n            self.assertIn('quality', assignment)\n    \n    def test_schedule_quality_calculation(self):\n        \"\"\"Test schedule quality score calculation.\"\"\"\n        scheduler = LeagueScheduler(self.league)\n        \n        # Create a mock schedule\n        mock_schedule = {\n            0: {\n                'match_pair': (self.teams[0], self.teams[1]),\n                'time_slot': {\n                    'datetime': timezone.now() + timedelta(days=1),\n                    'court': self.courts[0],\n                    'quality_score': 80.0\n                },\n                'quality': 80.0\n            },\n            1: {\n                'match_pair': (self.teams[2], self.teams[3]),\n                'time_slot': {\n                    'datetime': timezone.now() + timedelta(days=2),\n                    'court': self.courts[1],\n                    'quality_score': 75.0\n                },\n                'quality': 75.0\n            }\n        }\n        \n        quality_score = scheduler._calculate_quality_score(mock_schedule)\n        \n        # Should return a score between 0 and 100\n        self.assertGreaterEqual(quality_score, 0)\n        self.assertLessEqual(quality_score, 100)\n    \n    def test_full_schedule_generation(self):\n        \"\"\"Test complete schedule generation process.\"\"\"\n        scheduler = LeagueScheduler(self.league)\n        \n        # Generate schedule\n        league_schedule = scheduler.generate_schedule(algorithm='genetic')\n        \n        # Verify schedule was created\n        self.assertIsInstance(league_schedule, LeagueSchedule)\n        self.assertEqual(league_schedule.league, self.league)\n        self.assertIsNotNone(league_schedule.quality_score)\n        \n        # Verify matches were created\n        matches = self.league.matches.all()\n        self.assertGreater(matches.count(), 0)\n        \n        # Verify optimization run was recorded\n        optimization_run = self.league.optimizations.first()\n        self.assertIsNotNone(optimization_run)\n        self.assertEqual(optimization_run.status, 'completed')\n    \n    def test_schedule_with_constraints(self):\n        \"\"\"Test schedule generation with constraints.\"\"\"\n        # Add a blackout date constraint\n        blackout_date = (timezone.now().date() + timedelta(days=14)).isoformat()\n        ScheduleConstraint.objects.create(\n            league=self.league,\n            constraint_type='blackout_dates',\n            priority=1,\n            parameters={'dates': [blackout_date]},\n            description='Test blackout date'\n        )\n        \n        scheduler = LeagueScheduler(self.league)\n        league_schedule = scheduler.generate_schedule()\n        \n        # Verify no matches scheduled on blackout date\n        matches_on_blackout = self.league.matches.filter(\n            scheduled_datetime__date=blackout_date\n        )\n        self.assertEqual(matches_on_blackout.count(), 0)\n\n\nclass GeographicOptimizerTestCase(TestCase):\n    \"\"\"Test cases for Geographic Optimizer.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test data.\"\"\"\n        # Create test league with teams that have locations\n        self.user = User.objects.create_user(\n            username='geouser',\n            email='geo@example.com',\n            password='testpass'\n        )\n        \n        self.club = Club.objects.create(\n            name='Geo Club',\n            address='Geo Address',\n            city='Geo City'\n        )\n        \n        self.league = League.objects.create(\n            club=self.club,\n            name='Geographic League',\n            format='round_robin',\n            frequency='weekly',\n            start_date=timezone.now().date() + timedelta(days=7),\n            end_date=timezone.now().date() + timedelta(days=90)\n        )\n        \n        # Create teams with different locations\n        locations = [\n            (40.7128, -74.0060),  # New York\n            (40.7589, -73.9851),  # Near NYC\n            (40.6782, -73.9442),  # Brooklyn\n            (40.7831, -73.9712),  # Upper Manhattan\n            (41.8781, -87.6298),  # Chicago (far)\n            (41.8500, -87.6500),  # Near Chicago\n        ]\n        \n        self.teams = []\n        for i, (lat, lng) in enumerate(locations):\n            # Create players\n            player1 = User.objects.create_user(\n                username=f'geoplayer{i*2+1}',\n                email=f'geoplayer{i*2+1}@example.com'\n            )\n            player2 = User.objects.create_user(\n                username=f'geoplayer{i*2+2}',\n                email=f'geoplayer{i*2+2}@example.com'\n            )\n            \n            profile1 = ClientProfile.objects.create(user=player1)\n            profile2 = ClientProfile.objects.create(user=player2)\n            \n            team = LeagueTeam.objects.create(\n                league=self.league,\n                name=f'GeoTeam {i+1}',\n                player1=profile1,\n                player2=profile2,\n                location_lat=lat,\n                location_lng=lng\n            )\n            self.teams.append(team)\n    \n    def test_team_clustering(self):\n        \"\"\"Test geographic clustering of teams.\"\"\"\n        optimizer = GeographicOptimizer(self.league)\n        clusters = optimizer.cluster_teams_by_location(num_clusters=2)\n        \n        # Should create 2 clusters\n        self.assertEqual(len(clusters), 2)\n        \n        # Should have teams in each cluster\n        for cluster_teams in clusters.values():\n            self.assertGreater(len(cluster_teams), 0)\n    \n    def test_optimal_cluster_determination(self):\n        \"\"\"Test automatic optimal cluster determination.\"\"\"\n        optimizer = GeographicOptimizer(self.league)\n        optimal_clusters = optimizer._determine_optimal_clusters()\n        \n        # Should return reasonable number of clusters for 6 teams\n        self.assertGreaterEqual(optimal_clusters, 1)\n        self.assertLessEqual(optimal_clusters, 4)\n    \n    def test_travel_matrix_calculation(self):\n        \"\"\"Test travel distance matrix calculation.\"\"\"\n        optimizer = GeographicOptimizer(self.league)\n        travel_matrix = optimizer.calculate_travel_matrix()\n        \n        # Should have distances between all team pairs\n        expected_pairs = len(self.teams) * (len(self.teams) - 1)\n        self.assertEqual(len(travel_matrix), expected_pairs)\n        \n        # All distances should be positive\n        for distance in travel_matrix.values():\n            self.assertGreater(distance, 0)\n    \n    def test_travel_report_generation(self):\n        \"\"\"Test travel analysis report generation.\"\"\"\n        optimizer = GeographicOptimizer(self.league)\n        report = optimizer.generate_travel_report()\n        \n        # Report should contain expected sections\n        self.assertIn('total_teams', report)\n        self.assertIn('travel_statistics', report)\n        self.assertIn('cluster_details', report)\n        self.assertIn('recommendations', report)\n        \n        # Statistics should be reasonable\n        stats = report['travel_statistics']\n        self.assertGreater(stats['max_distance_km'], stats['min_distance_km'])\n    \n    def test_division_suggestions(self):\n        \"\"\"Test optimal division structure suggestions.\"\"\"\n        optimizer = GeographicOptimizer(self.league)\n        divisions = optimizer.suggest_optimal_divisions(max_teams_per_division=4)\n        \n        # Should create divisions\n        self.assertGreater(len(divisions), 0)\n        \n        # Each division should not exceed max size\n        for division in divisions:\n            self.assertLessEqual(len(division), 4)\n        \n        # All teams should be assigned\n        all_teams = [team for division in divisions for team in division]\n        self.assertEqual(len(all_teams), len(self.teams))\n\n\nclass MatchReschedulerTestCase(TestCase):\n    \"\"\"Test cases for Match Rescheduler.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test data.\"\"\"\n        self.user = User.objects.create_user(\n            username='rescheduser',\n            email='resched@example.com',\n            password='testpass'\n        )\n        \n        self.club = Club.objects.create(\n            name='Resched Club',\n            address='Resched Address'\n        )\n        \n        self.court = Court.objects.create(\n            club=self.club,\n            name='Resched Court',\n            is_active=True\n        )\n        \n        self.league = League.objects.create(\n            club=self.club,\n            name='Resched League',\n            format='round_robin',\n            frequency='weekly',\n            start_date=timezone.now().date(),\n            end_date=timezone.now().date() + timedelta(days=90)\n        )\n        \n        # Create teams\n        self.teams = []\n        for i in range(4):\n            player1 = User.objects.create_user(\n                username=f'reschplayer{i*2+1}',\n                email=f'reschplayer{i*2+1}@example.com'\n            )\n            player2 = User.objects.create_user(\n                username=f'reschplayer{i*2+2}',\n                email=f'reschplayer{i*2+2}@example.com'\n            )\n            \n            profile1 = ClientProfile.objects.create(user=player1)\n            profile2 = ClientProfile.objects.create(user=player2)\n            \n            team = LeagueTeam.objects.create(\n                league=self.league,\n                name=f'ReschedTeam {i+1}',\n                player1=profile1,\n                player2=profile2\n            )\n            self.teams.append(team)\n        \n        # Create a test match\n        self.match = LeagueMatch.objects.create(\n            club=self.club,\n            league=self.league,\n            round_number=1,\n            match_number=1,\n            home_team=self.teams[0],\n            away_team=self.teams[1],\n            scheduled_datetime=timezone.now() + timedelta(days=1),\n            court=self.court,\n            status='scheduled'\n        )\n    \n    def test_single_match_rescheduling(self):\n        \"\"\"Test rescheduling a single match.\"\"\"\n        rescheduler = MatchRescheduler(self.league)\n        \n        reason = RescheduleReason(\n            type='request',\n            description='Player request',\n            priority=3\n        )\n        \n        original_datetime = self.match.scheduled_datetime\n        success = rescheduler.reschedule_match(self.match, reason)\n        \n        if success:  # If alternative slots were found\n            # Reload match to check changes\n            self.match.refresh_from_db()\n            self.assertNotEqual(self.match.scheduled_datetime, original_datetime)\n    \n    def test_weather_cancellation(self):\n        \"\"\"Test weather-related match cancellation and rescheduling.\"\"\"\n        # Create multiple matches for the same date\n        tomorrow = timezone.now().date() + timedelta(days=1)\n        matches = []\n        \n        for i in range(2, 4):  # Create 2 more matches\n            match = LeagueMatch.objects.create(\n                club=self.club,\n                league=self.league,\n                round_number=1,\n                match_number=i,\n                home_team=self.teams[i-1],\n                away_team=self.teams[i % len(self.teams)],\n                scheduled_datetime=timezone.make_aware(\n                    datetime.combine(tomorrow, time(19, 0))\n                ),\n                court=self.court,\n                status='scheduled'\n            )\n            matches.append(match)\n        \n        rescheduler = MatchRescheduler(self.league)\n        results = rescheduler.handle_weather_cancellation(tomorrow, weather_type='rain')\n        \n        # Results should contain categorized matches\n        self.assertIn('successfully_rescheduled', results)\n        self.assertIn('failed_to_reschedule', results)\n        self.assertIn('requires_manual_intervention', results)\n    \n    def test_schedule_compression(self):\n        \"\"\"Test schedule compression to meet deadline.\"\"\"\n        # Create multiple future matches\n        future_matches = []\n        start_date = timezone.now().date() + timedelta(days=10)\n        \n        for i in range(3):\n            match = LeagueMatch.objects.create(\n                club=self.club,\n                league=self.league,\n                round_number=2,\n                match_number=i+1,\n                home_team=self.teams[i],\n                away_team=self.teams[(i+1) % len(self.teams)],\n                scheduled_datetime=timezone.make_aware(\n                    datetime.combine(start_date + timedelta(days=i*7), time(19, 0))\n                ),\n                court=self.court,\n                status='scheduled'\n            )\n            future_matches.append(match)\n        \n        rescheduler = MatchRescheduler(self.league)\n        target_date = start_date + timedelta(days=14)  # Compress to 2 weeks\n        \n        success = rescheduler.compress_schedule(target_date, max_matches_per_day=2)\n        \n        # If compression was possible, all matches should be before target date\n        if success:\n            for match in future_matches:\n                match.refresh_from_db()\n                self.assertLessEqual(match.scheduled_datetime.date(), target_date)\n    \n    def test_bulk_rescheduling(self):\n        \"\"\"Test bulk rescheduling of multiple matches.\"\"\"\n        # Create multiple matches to reschedule\n        matches_to_reschedule = []\n        for i in range(2, 4):\n            match = LeagueMatch.objects.create(\n                club=self.club,\n                league=self.league,\n                round_number=1,\n                match_number=i,\n                home_team=self.teams[i-1],\n                away_team=self.teams[i % len(self.teams)],\n                scheduled_datetime=timezone.now() + timedelta(days=2),\n                court=self.court,\n                status='scheduled'\n            )\n            matches_to_reschedule.append(match)\n        \n        rescheduler = MatchRescheduler(self.league)\n        \n        reason = RescheduleReason(\n            type='facility',\n            description='Court maintenance',\n            priority=2,\n            affects_multiple=True\n        )\n        \n        results = rescheduler.bulk_reschedule(matches_to_reschedule, reason)\n        \n        # Should have results for each category\n        total_matches = (\n            len(results['successfully_rescheduled']) +\n            len(results['failed_to_reschedule']) +\n            len(results['requires_manual_intervention'])\n        )\n        \n        self.assertEqual(total_matches, len(matches_to_reschedule))\n\n\n@pytest.mark.integration\nclass LeagueSchedulingIntegrationTest(TestCase):\n    \"\"\"Integration tests for the complete league scheduling system.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up complete test environment.\"\"\"\n        self.user = User.objects.create_user(\n            username='integration_user',\n            email='integration@example.com',\n            password='testpass'\n        )\n        \n        self.club = Club.objects.create(\n            name='Integration Club',\n            address='Integration Address',\n            latitude=40.7128,\n            longitude=-74.0060\n        )\n        \n        # Create multiple courts\n        self.courts = []\n        for i in range(5):\n            court = Court.objects.create(\n                club=self.club,\n                name=f'Integration Court {i+1}',\n                is_active=True\n            )\n            self.courts.append(court)\n        \n        # Create league with realistic settings\n        self.league = League.objects.create(\n            club=self.club,\n            name='Integration League',\n            description='Full integration test league',\n            format='round_robin',\n            frequency='weekly',\n            start_date=timezone.now().date() + timedelta(days=14),\n            end_date=timezone.now().date() + timedelta(days=120),\n            preferred_start_hour=time(18, 0),\n            preferred_end_hour=time(22, 0),\n            weekend_play=True,\n            weekday_play=True,\n            home_away=True,\n            max_travel_distance=50,\n            is_active=True\n        )\n        \n        # Create realistic teams with geographic spread\n        team_data = [\n            ('Team Alpha', 40.7128, -74.0060),\n            ('Team Beta', 40.7589, -73.9851),\n            ('Team Gamma', 40.6782, -73.9442),\n            ('Team Delta', 40.7831, -73.9712),\n            ('Team Epsilon', 40.7414, -74.0055),\n            ('Team Zeta', 40.7505, -73.9934),\n            ('Team Eta', 40.7282, -73.9942),\n            ('Team Theta', 40.7614, -73.9776),\n        ]\n        \n        self.teams = []\n        for i, (name, lat, lng) in enumerate(team_data):\n            # Create players\n            player1 = User.objects.create_user(\n                username=f'intplayer{i*2+1}',\n                email=f'intplayer{i*2+1}@example.com',\n                first_name=f'Player{i*2+1}',\n                last_name='Integration'\n            )\n            player2 = User.objects.create_user(\n                username=f'intplayer{i*2+2}',\n                email=f'intplayer{i*2+2}@example.com',\n                first_name=f'Player{i*2+2}',\n                last_name='Integration'\n            )\n            \n            profile1 = ClientProfile.objects.create(user=player1)\n            profile2 = ClientProfile.objects.create(user=player2)\n            \n            team = LeagueTeam.objects.create(\n                league=self.league,\n                name=name,\n                player1=profile1,\n                player2=profile2,\n                division=1,\n                location_lat=lat,\n                location_lng=lng,\n                availability_preferences={\n                    'preferred_days': ['monday', 'wednesday', 'friday'],\n                    'preferred_times': ['evening']\n                }\n            )\n            self.teams.append(team)\n        \n        # Add scheduling constraints\n        ScheduleConstraint.objects.create(\n            league=self.league,\n            constraint_type='blackout_dates',\n            priority=1,\n            parameters={\n                'dates': [(timezone.now().date() + timedelta(days=30)).isoformat()]\n            },\n            description='Holiday blackout'\n        )\n        \n        ScheduleConstraint.objects.create(\n            league=self.league,\n            constraint_type='travel_distance',\n            priority=2,\n            parameters={'max_distance_km': 25},\n            description='Maximum travel distance'\n        )\n    \n    def test_complete_league_workflow(self):\n        \"\"\"Test complete league scheduling workflow.\"\"\"\n        # 1. Generate initial schedule\n        scheduler = LeagueScheduler(self.league)\n        league_schedule = scheduler.generate_schedule(algorithm='genetic')\n        \n        # Verify schedule creation\n        self.assertIsInstance(league_schedule, LeagueSchedule)\n        self.assertGreater(league_schedule.quality_score, 0)\n        \n        # Verify matches were created\n        matches = self.league.matches.all()\n        expected_matches = 8 * 7 // 2  # Round-robin for 8 teams\n        self.assertEqual(matches.count(), expected_matches)\n        \n        # 2. Test geographic optimization\n        geo_optimizer = GeographicOptimizer(self.league)\n        travel_report = geo_optimizer.generate_travel_report()\n        \n        self.assertIn('travel_statistics', travel_report)\n        self.assertGreater(travel_report['total_teams'], 0)\n        \n        # 3. Test rescheduling capability\n        test_match = matches.first()\n        rescheduler = MatchRescheduler(self.league)\n        \n        reason = RescheduleReason(\n            type='request',\n            description='Integration test rescheduling',\n            priority=3\n        )\n        \n        original_time = test_match.scheduled_datetime\n        success = rescheduler.reschedule_match(test_match, reason)\n        \n        # If rescheduling was successful, time should change\n        if success:\n            test_match.refresh_from_db()\n            self.assertNotEqual(test_match.scheduled_datetime, original_time)\n        \n        # 4. Test schedule quality metrics\n        optimization = self.league.optimizations.filter(status='completed').first()\n        self.assertIsNotNone(optimization)\n        self.assertGreater(optimization.quality_score, 0)\n    \n    def test_schedule_with_complex_constraints(self):\n        \"\"\"Test scheduling with multiple complex constraints.\"\"\"\n        # Add more constraints\n        ScheduleConstraint.objects.create(\n            league=self.league,\n            constraint_type='time_preference',\n            priority=2,\n            parameters={\n                'preferred_hours': [19, 20, 21],\n                'avoid_hours': [8, 9, 10, 11, 12]\n            },\n            description='Prime time preference'\n        )\n        \n        ScheduleConstraint.objects.create(\n            league=self.league,\n            constraint_type='rest_period',\n            priority=1,\n            parameters={'min_hours_between_matches': 48},\n            description='Minimum rest period'\n        )\n        \n        scheduler = LeagueScheduler(self.league)\n        league_schedule = scheduler.generate_schedule(algorithm='constraint_solver')\n        \n        # Should still create valid schedule despite constraints\n        self.assertIsInstance(league_schedule, LeagueSchedule)\n        \n        # Check constraint compliance\n        matches = self.league.matches.all()\n        for match in matches:\n            # Check time preferences\n            match_hour = match.scheduled_datetime.hour\n            self.assertNotIn(match_hour, [8, 9, 10, 11, 12])\n    \n    def test_performance_benchmarks(self):\n        \"\"\"Test that scheduling meets performance benchmarks.\"\"\"\n        import time\n        \n        scheduler = LeagueScheduler(self.league)\n        \n        # Measure schedule generation time\n        start_time = time.time()\n        league_schedule = scheduler.generate_schedule(algorithm='genetic')\n        generation_time = time.time() - start_time\n        \n        # Should complete within reasonable time (10 seconds for 8 teams)\n        self.assertLess(generation_time, 10.0)\n        \n        # Quality score should meet minimum threshold\n        self.assertGreater(league_schedule.quality_score, 50.0)\n        \n        # Check optimization metrics\n        optimization = self.league.optimizations.filter(status='completed').first()\n        self.assertIsNotNone(optimization)\n        self.assertLess(optimization.duration_seconds, 10.0)\n    \n    def test_error_handling_and_recovery(self):\n        \"\"\"Test error handling and recovery scenarios.\"\"\"\n        # Test with insufficient teams\n        small_league = League.objects.create(\n            club=self.club,\n            name='Small League',\n            format='round_robin',\n            frequency='weekly',\n            start_date=timezone.now().date() + timedelta(days=7),\n            end_date=timezone.now().date() + timedelta(days=30)\n        )\n        \n        # Create only 2 teams (insufficient for round-robin)\n        for i in range(2):\n            player1 = User.objects.create_user(\n                username=f'smallplayer{i*2+1}',\n                email=f'smallplayer{i*2+1}@example.com'\n            )\n            player2 = User.objects.create_user(\n                username=f'smallplayer{i*2+2}',\n                email=f'smallplayer{i*2+2}@example.com'\n            )\n            \n            profile1 = ClientProfile.objects.create(user=player1)\n            profile2 = ClientProfile.objects.create(user=player2)\n            \n            LeagueTeam.objects.create(\n                league=small_league,\n                name=f'SmallTeam {i+1}',\n                player1=profile1,\n                player2=profile2\n            )\n        \n        scheduler = LeagueScheduler(small_league)\n        \n        # Should handle gracefully (though may not generate optimal schedule)\n        try:\n            league_schedule = scheduler.generate_schedule()\n            # If it succeeds, should create some kind of schedule\n            self.assertIsInstance(league_schedule, LeagueSchedule)\n        except Exception as e:\n            # If it fails, should be a meaningful error\n            self.assertIn('team', str(e).lower())\n    \n    def test_schedule_modification_and_updates(self):\n        \"\"\"Test modifying and updating existing schedules.\"\"\"\n        # Generate initial schedule\n        scheduler = LeagueScheduler(self.league)\n        initial_schedule = scheduler.generate_schedule()\n        initial_matches_count = self.league.matches.count()\n        \n        # Add a new team\n        new_player1 = User.objects.create_user(\n            username='newplayer1',\n            email='newplayer1@example.com'\n        )\n        new_player2 = User.objects.create_user(\n            username='newplayer2',\n            email='newplayer2@example.com'\n        )\n        \n        new_profile1 = ClientProfile.objects.create(user=new_player1)\n        new_profile2 = ClientProfile.objects.create(user=new_player2)\n        \n        new_team = LeagueTeam.objects.create(\n            league=self.league,\n            name='New Team',\n            player1=new_profile1,\n            player2=new_profile2,\n            location_lat=40.7500,\n            location_lng=-73.9900\n        )\n        \n        # Re-generate schedule with new team\n        updated_schedule = scheduler.generate_schedule(algorithm='genetic')\n        updated_matches_count = self.league.matches.count()\n        \n        # Should have more matches with additional team\n        # 9 teams = 9*8/2 = 36 matches vs 8 teams = 8*7/2 = 28 matches\n        expected_increase = 9 + 8  # New team plays against 8 existing teams\n        self.assertGreaterEqual(\n            updated_matches_count - initial_matches_count,\n            expected_increase\n        )